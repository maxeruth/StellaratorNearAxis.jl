<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation · StellaratorNearAxis</title><meta name="title" content="Documentation · StellaratorNearAxis"/><meta property="og:title" content="Documentation · StellaratorNearAxis"/><meta property="twitter:title" content="Documentation · StellaratorNearAxis"/><meta name="description" content="Documentation for StellaratorNearAxis."/><meta property="og:description" content="Documentation for StellaratorNearAxis."/><meta property="twitter:description" content="Documentation for StellaratorNearAxis."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StellaratorNearAxis</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">StellaratorNearAxis.jl</a></li><li class="is-active"><a class="tocitem" href>Documentation</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Structs"><span>Structs</span></a></li><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#Operations"><span>Operations</span></a></li><li><a class="tocitem" href="#Helper-Functions"><span>Helper Functions</span></a></li><li><a class="tocitem" href="#Coil-Functions"><span>Coil Functions</span></a></li><li><a class="tocitem" href="#Direct-Frenet-Serret-Equilibrium-Problem"><span>Direct Frenet-Serret Equilibrium Problem</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li></ul></li><li><a class="tocitem" href="../../examples/example/">Example</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/maxeruth/StellaratorNearAxis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/main/docs/src/lib/PowerSeries.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h1><p>This is the documentation for StellaratorNearAxis.jl structs and their operations.</p><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Documentation">Documentation</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li><li><a href="#Structs">Structs</a></li><li><a href="#Constructors">Constructors</a></li><li><a href="#Operations">Operations</a></li><li><a href="#Helper-Functions">Helper Functions</a></li><li><a href="#Coil-Functions">Coil Functions</a></li><li><a href="#Direct-Frenet-Serret-Equilibrium-Problem">Direct Frenet-Serret Equilibrium Problem</a></li><li><a href="#Plotting">Plotting</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#StellaratorNearAxis.Coil"><code>StellaratorNearAxis.Coil</code></a></li><li><a href="#StellaratorNearAxis.DirectNearAxisEquilibrium"><code>StellaratorNearAxis.DirectNearAxisEquilibrium</code></a></li><li><a href="#StellaratorNearAxis.FluxPowerSeries"><code>StellaratorNearAxis.FluxPowerSeries</code></a></li><li><a href="#StellaratorNearAxis.IdentityPowerSeries"><code>StellaratorNearAxis.IdentityPowerSeries</code></a></li><li><a href="#StellaratorNearAxis.PowerSeriesRho"><code>StellaratorNearAxis.PowerSeriesRho</code></a></li><li><a href="#StellaratorNearAxis.SpatialPowerSeries"><code>StellaratorNearAxis.SpatialPowerSeries</code></a></li><li><a href="#StellaratorNearAxis.SpatialPowerSeries-Union{Tuple{SpectralPowerSeries{T}}, Tuple{T}} where T"><code>StellaratorNearAxis.SpatialPowerSeries</code></a></li><li><a href="#StellaratorNearAxis.SpectralPowerSeries"><code>StellaratorNearAxis.SpectralPowerSeries</code></a></li><li><a href="#StellaratorNearAxis.SpectralPowerSeries-Union{Tuple{SpatialPowerSeries{T}}, Tuple{T}} where T"><code>StellaratorNearAxis.SpectralPowerSeries</code></a></li><li><a href="#StellaratorNearAxis.ZeroPowerSeries"><code>StellaratorNearAxis.ZeroPowerSeries</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{AbstractPowerSeries{T}, AbstractPowerSeries{T}}} where T"><code>Base.:*</code></a></li><li><a href="#Base.:*-Tuple{Number, AbstractPowerSeries}"><code>Base.:*</code></a></li><li><a href="#Base.:+-Tuple{AbstractPowerSeries, AbstractPowerSeries}"><code>Base.:+</code></a></li><li><a href="#Base.:--Tuple{AbstractPowerSeries}"><code>Base.:-</code></a></li><li><a href="#Base.:--Tuple{AbstractPowerSeries, AbstractPowerSeries}"><code>Base.:-</code></a></li><li><a href="#Base.:/-Union{Tuple{T}, Tuple{AbstractPowerSeries{T}, AbstractPowerSeries{T}}} where T"><code>Base.:/</code></a></li><li><a href="#Base.:^-Tuple{AbstractPowerSeries, Number}"><code>Base.:^</code></a></li><li><a href="#Base.Math.sincos-Tuple{AbstractPowerSeries, Number}"><code>Base.Math.sincos</code></a></li><li><a href="#Base.cos-Tuple{AbstractPowerSeries, Number}"><code>Base.cos</code></a></li><li><a href="#Base.cosh-Union{Tuple{T}, Tuple{AbstractPowerSeries{T}, T}} where T"><code>Base.cosh</code></a></li><li><a href="#Base.div"><code>Base.div</code></a></li><li><a href="#Base.exp-Union{Tuple{T}, Tuple{AbstractPowerSeries{T}, T}} where T"><code>Base.exp</code></a></li><li><a href="#Base.inv-Tuple{AbstractPowerSeries}"><code>Base.inv</code></a></li><li><a href="#Base.similar-Union{Tuple{SpatialPowerSeries{T}}, Tuple{T}} where T"><code>Base.similar</code></a></li><li><a href="#Base.sin-Tuple{AbstractPowerSeries, Number}"><code>Base.sin</code></a></li><li><a href="#Base.sinh-Union{Tuple{T}, Tuple{AbstractPowerSeries{T}, T}} where T"><code>Base.sinh</code></a></li><li><a href="#LinearAlgebra.norm-Tuple{AbstractVector{&lt;:AbstractPowerSeries}}"><code>LinearAlgebra.norm</code></a></li><li><a href="#StellaratorNearAxis.Fnorm"><code>StellaratorNearAxis.Fnorm</code></a></li><li><a href="#StellaratorNearAxis.InitialVacuumNearAxisEquilibrium"><code>StellaratorNearAxis.InitialVacuumNearAxisEquilibrium</code></a></li><li><a href="#StellaratorNearAxis.L2norm-Tuple{AbstractPowerSeries, Number}"><code>StellaratorNearAxis.L2norm</code></a></li><li><a href="#StellaratorNearAxis.change_order-Union{Tuple{T}, Tuple{AbstractPowerSeries{T}, Integer}} where T"><code>StellaratorNearAxis.change_order</code></a></li><li><a href="#StellaratorNearAxis.compose"><code>StellaratorNearAxis.compose</code></a></li><li><a href="#StellaratorNearAxis.composition_basis"><code>StellaratorNearAxis.composition_basis</code></a></li><li><a href="#StellaratorNearAxis.distribute_p0-Tuple{AbstractPowerSeries, Integer}"><code>StellaratorNearAxis.distribute_p0</code></a></li><li><a href="#StellaratorNearAxis.evaluate-Tuple{SpectralPowerSeries, Union{Number, AbstractVector}, Union{Number, AbstractVector}, Union{Number, AbstractVector}}"><code>StellaratorNearAxis.evaluate</code></a></li><li><a href="#StellaratorNearAxis.evaluate-Union{Tuple{T}, Tuple{AbstractArray{T}, Coil}} where T"><code>StellaratorNearAxis.evaluate</code></a></li><li><a href="#StellaratorNearAxis.field_to_nae"><code>StellaratorNearAxis.field_to_nae</code></a></li><li><a href="#StellaratorNearAxis.find_magnetic_axis"><code>StellaratorNearAxis.find_magnetic_axis</code></a></li><li><a href="#StellaratorNearAxis.fit_SpectralPowerSeries"><code>StellaratorNearAxis.fit_SpectralPowerSeries</code></a></li><li><a href="#StellaratorNearAxis.flux_compose-Union{Tuple{T}, Tuple{FluxPowerSeries{T}, SpatialPowerSeries{T}}} where T"><code>StellaratorNearAxis.flux_compose</code></a></li><li><a href="#StellaratorNearAxis.flux_contours!"><code>StellaratorNearAxis.flux_contours!</code></a></li><li><a href="#StellaratorNearAxis.flux_surface_plot!"><code>StellaratorNearAxis.flux_surface_plot!</code></a></li><li><a href="#StellaratorNearAxis.get_field_on_axis"><code>StellaratorNearAxis.get_field_on_axis</code></a></li><li><a href="#StellaratorNearAxis.get_flux_coordinates"><code>StellaratorNearAxis.get_flux_coordinates</code></a></li><li><a href="#StellaratorNearAxis.grad"><code>StellaratorNearAxis.grad</code></a></li><li><a href="#StellaratorNearAxis.invert_coordinates"><code>StellaratorNearAxis.invert_coordinates</code></a></li><li><a href="#StellaratorNearAxis.load_coils"><code>StellaratorNearAxis.load_coils</code></a></li><li><a href="#StellaratorNearAxis.magnetic_trajectory"><code>StellaratorNearAxis.magnetic_trajectory</code></a></li><li><a href="#StellaratorNearAxis.plot_curve!"><code>StellaratorNearAxis.plot_curve!</code></a></li><li><a href="#StellaratorNearAxis.remove_zeros-Tuple{AbstractPowerSeries}"><code>StellaratorNearAxis.remove_zeros</code></a></li><li><a href="#StellaratorNearAxis.rho_antideriv-Tuple{AbstractPowerSeries}"><code>StellaratorNearAxis.rho_antideriv</code></a></li><li><a href="#StellaratorNearAxis.rho_deriv"><code>StellaratorNearAxis.rho_deriv</code></a></li><li><a href="#StellaratorNearAxis.rho_integrate"><code>StellaratorNearAxis.rho_integrate</code></a></li><li><a href="#StellaratorNearAxis.s_deriv"><code>StellaratorNearAxis.s_deriv</code></a></li><li><a href="#StellaratorNearAxis.surface_integrate"><code>StellaratorNearAxis.surface_integrate</code></a></li><li><a href="#StellaratorNearAxis.theta_deriv"><code>StellaratorNearAxis.theta_deriv</code></a></li><li><a href="#StellaratorNearAxis.unsafe_distribute_p0"><code>StellaratorNearAxis.unsafe_distribute_p0</code></a></li><li><a href="#StellaratorNearAxis.vacuum_solve"><code>StellaratorNearAxis.vacuum_solve</code></a></li><li><a href="#StellaratorNearAxis.volume_integrate"><code>StellaratorNearAxis.volume_integrate</code></a></li><li><a href="#StellaratorNearAxis.zero_FluxPowerSeries"><code>StellaratorNearAxis.zero_FluxPowerSeries</code></a></li><li><a href="#StellaratorNearAxis.zero_SpatialPowerSeries"><code>StellaratorNearAxis.zero_SpatialPowerSeries</code></a></li><li><a href="#StellaratorNearAxis.zero_SpectralPowerSeries"><code>StellaratorNearAxis.zero_SpectralPowerSeries</code></a></li></ul><h2 id="Structs"><a class="docs-heading-anchor" href="#Structs">Structs</a><a id="Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Structs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.PowerSeriesRho" href="#StellaratorNearAxis.PowerSeriesRho"><code>StellaratorNearAxis.PowerSeriesRho</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PowerSeriesRho</code></pre><p>A struct used for algebraically representing changes in order of power series, typically stored as <code>p0</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">A = zero_SpectralPowerSeries(1,1)
A[1].a[1] = 1.         # A is a constant SpectralPowerSeries
display(get_p0(A))     # The leading order of A is 0
ρ = PowerSeriesRho()
B = ρ^2*A
display(get_p0(B))     # The SpectralPowerSeries B is ρ^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/PowerSeries.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.ZeroPowerSeries" href="#StellaratorNearAxis.ZeroPowerSeries"><code>StellaratorNearAxis.ZeroPowerSeries</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ZeroPowerSeries{T} &lt;: AbstractPowerSeries{T}</code></pre><p>A power series representing the zero element.  Multiplication of an AbstractPowerSeries by a ZeroPowerSeries returns a ZeroPowerSeries, and addition of an AbstractPowerSeries <code>A</code> with a ZeroPowerSeries returns <code>A</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">A = zero_SpectralPowerSeries(1,1)
A[1].a[1] = 1.
Z = ZeroPowerSeries()
display(A*Z) # Returns a ZeroPowerSeries
display(A+Z) # Returns A</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/PowerSeries.jl#L60-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.IdentityPowerSeries" href="#StellaratorNearAxis.IdentityPowerSeries"><code>StellaratorNearAxis.IdentityPowerSeries</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IdentityPowerSeries{T} &lt;: AbstractPowerSeries{T}</code></pre><p>A power series representing the identity element.  Multiplication of an AbstractPowerSeries <code>A</code> by an IdentityPowerSeries returns <code>A</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">A = zero_SpectralPowerSeries(1,1)
A[1].a[1] = 2.
id = IdentityPowerSeries()
display(A*id) # Returns A</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/PowerSeries.jl#L82-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.FluxPowerSeries" href="#StellaratorNearAxis.FluxPowerSeries"><code>StellaratorNearAxis.FluxPowerSeries</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FluxPowerSeries{T} &lt;: AbstractPowerSeries{T}</code></pre><p>Formal power series that is a function of the flux surface, i.e. <code>A = A₀ + A₁ (ρ²)¹ + A₂ (ρ²)² + ...</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/PowerSeries.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.SpectralPowerSeries" href="#StellaratorNearAxis.SpectralPowerSeries"><code>StellaratorNearAxis.SpectralPowerSeries</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpectralPowerSeries{T} &lt;: AbstractPowerSeries{T}</code></pre><p>The basic spectral representation of near-axis series. A <code>SpectralPowerSeries</code> is composed of <code>SpectralPowerSeriesSlice</code>s, each of which can be accessed by getindex via <code>A[n]</code>. Each slice <code>n</code> contains an <code>M × n</code> array of Fourier coefficients, where  <code>M</code> is the number of coefficients in the <code>s</code> direction and <code>n</code> is the number of coefficients in the <code>θ</code> direction.  In the <code>s</code> direction, the coefficients are ordered as <code>1</code>, <code>sin(s)</code>, <code>cos(s)</code>, <code>sin(2s)</code>, ... In the odd <code>n</code> case in the <code>θ</code> direction, the coefficients are ordered as <code>1</code>, <code>sin(2θ)</code>, <code>cos(2θ)</code>, <code>sin(4θ)</code>, ... In the even <code>n</code> case in the <code>θ</code> direction, the coefficients are ordered as <code>cos(θ)</code>, <code>sin(θ)</code>, <code>cos(3θ)</code>, <code>sin(3θ)</code>, ... Derivative routines are defined for SpectralPowerSeries; see <a href="#StellaratorNearAxis.rho_deriv"><code>rho_deriv</code></a>, <a href="#StellaratorNearAxis.theta_deriv"><code>theta_deriv</code></a>, <a href="#StellaratorNearAxis.s_deriv"><code>s_deriv</code></a>, <a href="#StellaratorNearAxis.grad"><code>grad</code></a>, <a href="#Base.div"><code>div</code></a>.</p><p><strong>Example</strong></p><p>Create a power series representing <code>y = ρ sin(θ)</code></p><pre><code class="nohighlight hljs">M = 5                              # Number of modes in s
N = 3                              # Number of orders in rho
y = zero_SpectralPowerSeries(M, N) # Create a SpectralPowerSeries
y[2].a[1,2] = 1.                   # Set the ρ sin(θ) coefficient to 1
y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/PowerSeries.jl#L116-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.SpatialPowerSeries" href="#StellaratorNearAxis.SpatialPowerSeries"><code>StellaratorNearAxis.SpatialPowerSeries</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpatialPowerSeries{T} &lt;: AbstractPowerSeries{T}</code></pre><p>The representation of near-axis series on collocation nodes. A <code>SpatialPowerSeries</code> is composed of <code>SpatialPowerSeriesSlice</code>s, each of which can be accessed by getindex via <code>A[n]</code>. Each slice <code>n</code> contains an <code>M × n</code> array of sampled values, where  <code>M</code> is the number of samples in the <code>s</code> direction and <code>n</code> is the order in the <code>θ</code> direction.  The <code>s</code> points are ordered as <code>2(j-1)π/M</code> for <code>1≤j≤M</code>, while in the <code>θ</code> points are ordered as <code>2π(k-1)/(2n-1)</code> for <code>1≤k≤n</code>. Algebraic operations, such as <code>*</code>, <code>/</code>, <code>inv</code>, etc. are defined for SpatialPowerSeries</p><p><strong>Example</strong></p><p>Create a power series representing <code>y = ρ sin(θ)</code></p><pre><code class="nohighlight hljs">Mc = 5                             # Number of points in s
N = 3                              # Number of orders in rho
y = zero_SpectralPowerSeries(1, N) # Create a SpectralPowerSeries
y[2].a[1,2] = 1.                   # Set the ρ sin(θ) coefficient to 1
y_spatial = SpatialPowerSeries(y, M=Mc)
y_spatial</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/PowerSeries.jl#L154-L174">source</a></section></article><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.zero_SpectralPowerSeries" href="#StellaratorNearAxis.zero_SpectralPowerSeries"><code>StellaratorNearAxis.zero_SpectralPowerSeries</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>zero_SpectralPowerSeries(M::Integer, N::Integer; p0::Integer = 0)</p><p>Return a SpectralPowerSeries object initialized with zero coefficients.</p><p>Inputs:</p><ul><li><code>M</code>: Number of Fourier coefficients in the poloidal s coordinate</li><li><code>N</code>: Number of coefficients in radial ρ and toroidal θ coordinates</li><li><code>p0</code>: The leading order ρ coefficient</li></ul><p>Output:</p><ul><li>A zero SpectralPowerSeries</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/SpectralPowerSeries.jl#L40-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.zero_SpatialPowerSeries" href="#StellaratorNearAxis.zero_SpatialPowerSeries"><code>StellaratorNearAxis.zero_SpatialPowerSeries</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>zero_SpatialPowerSeries(M::Integer, N::Integer; p0::Integer = 0)</p><p>Return a SpatialPowerSeries object initialized with zero entries.</p><p>Inputs:</p><ul><li><code>M</code>: Number of nodes in the poloidal s coordinate</li><li><code>N</code>: Order in radial ρ and toroidal θ coordinates</li><li><code>p0</code>: The leading order ρ coefficient</li></ul><p>Output:</p><ul><li>A zero SpatialPowerSeries</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/SpatialPowerSeries.jl#L228-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.zero_FluxPowerSeries" href="#StellaratorNearAxis.zero_FluxPowerSeries"><code>StellaratorNearAxis.zero_FluxPowerSeries</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zero_FluxPowerSeries(N::Integer; p0::Integer=0)</code></pre><p>Create a FluxPowerSeries of degree <code>N</code> and leading coefficient <code>p0</code> with zero entries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/FluxPowerSeries.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.similar-Union{Tuple{SpatialPowerSeries{T}}, Tuple{T}} where T" href="#Base.similar-Union{Tuple{SpatialPowerSeries{T}}, Tuple{T}} where T"><code>Base.similar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">similar(A&lt;:AbstractPowerSeries; M=nothing, N=nothing, p0=nothing)</code></pre><p>Create a zero AbstractPowerSeries of the same type as <code>A</code> (except, in  the case of an IdentityPowerSeries, returns another IdentityPowerSeries). Can optionally set the number of Spatial/Spectral modes <code>M</code>, series order <code>N</code>, and order offset <code>p0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/SpatialPowerSeries.jl#L250-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.SpatialPowerSeries-Union{Tuple{SpectralPowerSeries{T}}, Tuple{T}} where T" href="#StellaratorNearAxis.SpatialPowerSeries-Union{Tuple{SpectralPowerSeries{T}}, Tuple{T}} where T"><code>StellaratorNearAxis.SpatialPowerSeries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpatialPowerSeries(A::SpectralPowerSeries{T}; M::Integer = -1) where {T}</code></pre><p>Transform a SpectralPowerSeries to a SpatialPowerSeries of the same order. By default, the output uses the same number of collocation nodes as the Fourier modes. Alternatively, the user can set <code>M</code> to choose a different number of nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/SpectralPowerSeries.jl#L301-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.SpectralPowerSeries-Union{Tuple{SpatialPowerSeries{T}}, Tuple{T}} where T" href="#StellaratorNearAxis.SpectralPowerSeries-Union{Tuple{SpatialPowerSeries{T}}, Tuple{T}} where T"><code>StellaratorNearAxis.SpectralPowerSeries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpectralPowerSeries(A::SpatialPowerSeries{T}; M::Integer=-1) where {T}</code></pre><p>Transform a SpatialPowerSeries to a SpectralPowerSeries of the same order. By default, the output uses the same number of Fourier modes as the number of spatial collocation nodes. Alternatively, the user can set <code>M</code> to choose a different number of modes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/SpectralPowerSeries.jl#L259-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.fit_SpectralPowerSeries" href="#StellaratorNearAxis.fit_SpectralPowerSeries"><code>StellaratorNearAxis.fit_SpectralPowerSeries</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fit_SpectralPowerSeries(a::AbstractArray, r::AbstractVector, M::Integer, N::Integer)</code></pre><p>Fit a SpectralPowerSeries to the samples of some function.</p><p>input:</p><ul><li><code>a</code>: A Nr × Nθ × Nϕ array of function samples. It is assumed that  <code>a[i,j,k] = f(r[i], θ[j], ϕ[k])</code>, where <code>r</code> is given as input, and <code>θ</code> and  <code>ϕ</code> are on a uniform grid from <code>0</code> to <code>2π</code></li><li><code>r</code>: The radial coordinates sampled at</li><li><code>N</code>: The order in ρ and θ the series is interpolated to</li><li><code>M</code>: The order in ϕ the series is interpolated to</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/SpectralPowerSeries.jl#L684-L696">source</a></section><section><div><pre><code class="language-julia hljs">fit_SpectralPowerSeries(a::AbstractArray, r::AbstractVector, M::Integer, N::Integer)</code></pre><p>Fit a SpectralPowerSeries to the samples of some function.</p><p>input:</p><ul><li><code>f</code>: A function from R^3→R, with signature <code>f(r,θ,ϕ)</code></li><li><code>r</code>: The radial coordinates sampled at</li><li><code>Nθ</code>: Number of θ samples</li><li><code>Nϕ</code>: Number of ϕ samples</li><li><code>N</code>: The order in ρ and θ the series is interpolated to</li><li><code>M</code>: The order in ϕ the series is interpolated to</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/SpectralPowerSeries.jl#L744-L756">source</a></section></article><h2 id="Operations"><a class="docs-heading-anchor" href="#Operations">Operations</a><a id="Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.evaluate-Tuple{SpectralPowerSeries, Union{Number, AbstractVector}, Union{Number, AbstractVector}, Union{Number, AbstractVector}}" href="#StellaratorNearAxis.evaluate-Tuple{SpectralPowerSeries, Union{Number, AbstractVector}, Union{Number, AbstractVector}, Union{Number, AbstractVector}}"><code>StellaratorNearAxis.evaluate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate(A::SpectralPowerSeries, rho::Union{Number, AbstractVector},
         theta::Union{Number, AbstractVector}, phi::Union{Number, AbstractVector})</code></pre><p>Evaluate the SpectralPowerSeries either at a point or on a grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/SpectralPowerSeries.jl#L478-L483">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:--Tuple{AbstractPowerSeries}" href="#Base.:--Tuple{AbstractPowerSeries}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">-(A::AbstractPowerSeries)</code></pre><p>Get the negative power series of <code>A</code> (i.e., <code>A + (-A) == 0</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{AbstractPowerSeries, AbstractPowerSeries}" href="#Base.:+-Tuple{AbstractPowerSeries, AbstractPowerSeries}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">+(A::AbstractPowerSeries, B::AbstractPowerSeries)</code></pre><p>Add two AbstractPowerSeries. May not work for all inputs (e.g. a SpectralPowerSeries and a SpatialPowerSeries).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:--Tuple{AbstractPowerSeries, AbstractPowerSeries}" href="#Base.:--Tuple{AbstractPowerSeries, AbstractPowerSeries}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">-(A::AbstractPowerSeries, B::AbstractPowerSeries)</code></pre><p>Subtract two AbstractPowerSeries. May not work for all inputs (e.g. a SpectralPowerSeries and a SpatialPowerSeries).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{AbstractPowerSeries{T}, AbstractPowerSeries{T}}} where T" href="#Base.:*-Union{Tuple{T}, Tuple{AbstractPowerSeries{T}, AbstractPowerSeries{T}}} where T"><code>Base.:*</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">*(A::AbstractPowerSeries{T}, B::AbstractPowerSeries{T};
       N::Integer=-1, careful::Bool=false, careful_tol::Number=1e-12) where {T}</code></pre><p>Multiply two power series together to get <code>C = A*B</code> to order <code>N</code>. If <code>careful==true</code>, the output order is determined by the leading order by which <code>A</code> and <code>B</code> are nonzero to tolerance <code>careful_tol</code>. In this case, the argument for <code>N</code> is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L100-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Tuple{Number, AbstractPowerSeries}" href="#Base.:*-Tuple{Number, AbstractPowerSeries}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">*(a::Number, A::AbstractPowerSeries)</code></pre><p>Multiply the power series <code>A</code> by a scalar number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.inv-Tuple{AbstractPowerSeries}" href="#Base.inv-Tuple{AbstractPowerSeries}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inv(A::AbstractPowerSeries; N::Integer = -1)</code></pre><p>Find the multiplicative inverse of <code>A</code> to order <code>N</code>. Approximately satisfies <code>A*inv(A)=1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L277-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:/-Union{Tuple{T}, Tuple{AbstractPowerSeries{T}, AbstractPowerSeries{T}}} where T" href="#Base.:/-Union{Tuple{T}, Tuple{AbstractPowerSeries{T}, AbstractPowerSeries{T}}} where T"><code>Base.:/</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">/(A::AbstractPowerSeries{T}, B::AbstractPowerSeries{T};
       N::Integer=-1, careful::Bool=false, careful_tol::Number=1e-12) where {T}</code></pre><p>Divide two power series to get <code>C = A/B</code> to order <code>N</code>.  Currently just calls inv() and *(), but could potentially be faster with a better method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L175-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.exp-Union{Tuple{T}, Tuple{AbstractPowerSeries{T}, T}} where T" href="#Base.exp-Union{Tuple{T}, Tuple{AbstractPowerSeries{T}, T}} where T"><code>Base.exp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp(A::AbstractPowerSeries{T}[, alpha::T]; N::Integer = -1) where {T}</code></pre><p>Exponentiate the power series <code>A</code> to get <code>e^(αA)</code> to order <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L312-L316">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sinh-Union{Tuple{T}, Tuple{AbstractPowerSeries{T}, T}} where T" href="#Base.sinh-Union{Tuple{T}, Tuple{AbstractPowerSeries{T}, T}} where T"><code>Base.sinh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sinh(A::AbstractPowerSeries{T}[, alpha::T]) where {T}</code></pre><p>Find <code>sinh(αA) = (e^(αA) - e^(-αA))/2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L337-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.cosh-Union{Tuple{T}, Tuple{AbstractPowerSeries{T}, T}} where T" href="#Base.cosh-Union{Tuple{T}, Tuple{AbstractPowerSeries{T}, T}} where T"><code>Base.cosh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cosh(A::AbstractPowerSeries{T}[, alpha::T]) where {T}</code></pre><p>Find <code>cosh(αA) = (e^(αA) + e^(-αA))/2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L347-L351">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Math.sincos-Tuple{AbstractPowerSeries, Number}" href="#Base.Math.sincos-Tuple{AbstractPowerSeries, Number}"><code>Base.Math.sincos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sincos(A::AbstractPowerSeries[, ω::Number])</code></pre><p>Find both the sine and cosine of <code>A</code>, i.e. <code>sin(ωA), cos(ωA) = sincos(A[, ω])</code> (note: both <code>sin</code> and <code>cos</code> call <code>sincos</code>), so calling this can save time if you require both)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L378-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sin-Tuple{AbstractPowerSeries, Number}" href="#Base.sin-Tuple{AbstractPowerSeries, Number}"><code>Base.sin</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sin(A::AbstractPowerSeries[, ω::Number])</code></pre><p>Finds the sine of a power series <code>sin(ωA)</code>. Note: if you also require <code>cos</code>, it is twice as efficient to call <code>sincos</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L404-L409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.cos-Tuple{AbstractPowerSeries, Number}" href="#Base.cos-Tuple{AbstractPowerSeries, Number}"><code>Base.cos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cos(A::AbstractPowerSeries[, ω::Number])</code></pre><p>Finds the cosine of a power series <code>cos(ωA)</code>. Note: if you also require <code>sin</code>, it is twice as efficient to call <code>sincos</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L415-L420">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:^-Tuple{AbstractPowerSeries, Number}" href="#Base.:^-Tuple{AbstractPowerSeries, Number}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">^(A::AbstractPowerSeries, alpha::Number; N::Integer=-1)</code></pre><p>Raise <code>A</code> to the power α to <code>N</code> terms in the power series, i.e. compute <code>A^α</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L450-L454">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.rho_deriv" href="#StellaratorNearAxis.rho_deriv"><code>StellaratorNearAxis.rho_deriv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rho_deriv(A::AbstractPowerSeries{T}) where {T}</code></pre><p>Finds the derivative of <code>A</code> with respect to <code>ρ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L594-L598">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.theta_deriv" href="#StellaratorNearAxis.theta_deriv"><code>StellaratorNearAxis.theta_deriv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">theta_deriv(A::SpectralPowerSeries{T}) where {T}</code></pre><p>Takes the derivative of <code>A</code> in the <code>θ</code> direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/SpectralPowerSeries.jl#L402-L406">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.s_deriv" href="#StellaratorNearAxis.s_deriv"><code>StellaratorNearAxis.s_deriv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">s_deriv(A::SpectralPowerSeries{T}) where {T}</code></pre><p>Takes the derivative of <code>A</code> with respect to <code>s</code>.</p><p>WARNING: currently this function is only defined for an odd number of Fourier modes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/SpectralPowerSeries.jl#L351-L357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.grad" href="#StellaratorNearAxis.grad"><code>StellaratorNearAxis.grad</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grad(A::SpectralPowerSeries{T}) where {T}</code></pre><p>Returns the &quot;gradient&quot; of <code>[dA/dρ, dA/dθ, dA/ds]</code>.  Note that for a true gradient, it is necessary to use the metric.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/SpectralPowerSeries.jl#L418-L423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.div" href="#Base.div"><code>Base.div</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">div(A::SpectralPowerSeries{T}) where {T}</code></pre><p>Returns the &quot;divergence&quot; <code>dA[1]/dρ + dA[2]/dθ + dA[3]/ds</code>.  Note that for a true divergence, it is necessary to use the metric.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/SpectralPowerSeries.jl#L429-L434">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.surface_integrate" href="#StellaratorNearAxis.surface_integrate"><code>StellaratorNearAxis.surface_integrate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surface_integrate(A::AbstractPowerSeries)</code></pre><p>Performs the surface integral ∫A dθ dϕ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L563-L567">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.rho_integrate" href="#StellaratorNearAxis.rho_integrate"><code>StellaratorNearAxis.rho_integrate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rho_integrate(A::AbstractPowerSeries)</code></pre><p>Perform the integral     <code>B(r) = ∫₀ʳ A(ρ) ρ dρ</code> See <a href="#StellaratorNearAxis.rho_antideriv-Tuple{AbstractPowerSeries}"><code>rho_antideriv</code></a> for the integral without the integrating factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L621-L627">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.rho_antideriv-Tuple{AbstractPowerSeries}" href="#StellaratorNearAxis.rho_antideriv-Tuple{AbstractPowerSeries}"><code>StellaratorNearAxis.rho_antideriv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rho_antideriv(A::AbstractPowerSeries)</code></pre><p>Perform the integral     <code>B(r) = ∫₀ʳ A(ρ) dρ</code> (note: unlike <a href="#StellaratorNearAxis.rho_integrate"><code>rho_integrate</code></a>, which includes an integrating factor for analytic integrals)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L639-L645">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.volume_integrate" href="#StellaratorNearAxis.volume_integrate"><code>StellaratorNearAxis.volume_integrate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">volume_integate(A::AbstractPowerSeries{T}; N::Integer=-1) where {T}</code></pre><p>Integral over a volume. Implemented by composing <a href="#StellaratorNearAxis.rho_integrate"><code>rho_integrate</code></a> with  <a href="#StellaratorNearAxis.surface_integrate"><code>surface_integrate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L658-L663">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{AbstractVector{&lt;:AbstractPowerSeries}}" href="#LinearAlgebra.norm-Tuple{AbstractVector{&lt;:AbstractPowerSeries}}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.norm(A::AbstractVector{&lt;:AbstractPowerSeries})</code></pre><p>Returns the norm of a power series <code>A</code>, i.e. <code>(A&#39;*A)^0.5</code>. For a norm of the elements of <code>A</code>, see <a href="#StellaratorNearAxis.Fnorm"><code>Fnorm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L544-L549">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.Fnorm" href="#StellaratorNearAxis.Fnorm"><code>StellaratorNearAxis.Fnorm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Fnorm(A::AbstractPowerSeries{T}) where {T}</code></pre><p>Frobenius norm of the elements of <code>A</code>. Useful for determining approximate equality of  AbstractPowerSeries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L669-L674">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.L2norm-Tuple{AbstractPowerSeries, Number}" href="#StellaratorNearAxis.L2norm-Tuple{AbstractPowerSeries, Number}"><code>StellaratorNearAxis.L2norm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">L2norm(A::AbstractPowerSeries, δ::Number)</code></pre><p>Find the L2 norm of a power series via near-axis operations. NOTE: this is not the true L2 norm; just the near-axis approximation of it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L769-L775">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.flux_compose-Union{Tuple{T}, Tuple{FluxPowerSeries{T}, SpatialPowerSeries{T}}} where T" href="#StellaratorNearAxis.flux_compose-Union{Tuple{T}, Tuple{FluxPowerSeries{T}, SpatialPowerSeries{T}}} where T"><code>StellaratorNearAxis.flux_compose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flux_compose(A::FluxPowerSeries{T}, B::SpatialPowerSeries{T}) where {T}</code></pre><p>Composes a FluxPowerSeries <code>A</code> with a SpatialPowerSeries <code>B</code>, i.e. <code>A∘B</code>. Useful, e.g., for composing the rotational transform with the flux. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/FluxPowerSeries.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.composition_basis" href="#StellaratorNearAxis.composition_basis"><code>StellaratorNearAxis.composition_basis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">composition_basis(F::AbstractVector{&lt;:SpectralPowerSeries})</code></pre><p>Get a basis of the form -<code>[[1], [ρF cos(θF), ρF sin(θF)], [ρF^2, ρF^2 cos(2 θF), ρF^2 sin(2 θF)], ...]</code> from the input of a SpectralPowerSeries -<code>F = [ρF cos(θF), ρF sin(θF)]</code> This can be used in conjunction with the function <code>compose</code> to find the composition of another SpectralPowerSeries with <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/SpectralPowerSeries.jl#L525-L534">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.compose" href="#StellaratorNearAxis.compose"><code>StellaratorNearAxis.compose</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compose(A::SpectralPowerSeries, Ftree::AbstractVector)</code></pre><p>Compose a SpectralPowerSeries <code>A</code> with the basis <code>Ftree</code>. See <a href="#StellaratorNearAxis.composition_basis"><code>composition_basis</code></a> for a method to obtain <code>Ftree</code> from a change-of-coordinates SpectralPowerSeries <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/SpectralPowerSeries.jl#L586-L592">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.invert_coordinates" href="#StellaratorNearAxis.invert_coordinates"><code>StellaratorNearAxis.invert_coordinates</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">invert_coordinates(F::AbstractVector)</code></pre><p>Invert the SpectralPowerSeries coordinate transform <code>F</code>. That is,  the composition via <a href="#StellaratorNearAxis.compose"><code>compose</code></a> of <code>F</code> with the output <code>G</code>  satisfies <code>F∘G(x) ≈ x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/SpectralPowerSeries.jl#L612-L618">source</a></section></article><h2 id="Helper-Functions"><a class="docs-heading-anchor" href="#Helper-Functions">Helper Functions</a><a id="Helper-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.remove_zeros-Tuple{AbstractPowerSeries}" href="#StellaratorNearAxis.remove_zeros-Tuple{AbstractPowerSeries}"><code>StellaratorNearAxis.remove_zeros</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_zeros(A::AbstractPowerSeries, tol=1e-10)</code></pre><p>If one has access to a power series <code>A = ρ^2N B</code>, returns the power series <code>B</code>. For example, when  the polar Laplacian is applied to a series, the output has zeros in the first two orders. This  removes those zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L740-L746">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.change_order-Union{Tuple{T}, Tuple{AbstractPowerSeries{T}, Integer}} where T" href="#StellaratorNearAxis.change_order-Union{Tuple{T}, Tuple{AbstractPowerSeries{T}, Integer}} where T"><code>StellaratorNearAxis.change_order</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">change_order(A::AbstractPowerSeries{T}, N::Integer) where {T}</code></pre><p>Creates a new PowerSeries with the coefficients of <code>A</code> with  order <code>N</code>. If <code>N &gt; get_N(A)</code>, the extra coefficients are set to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/PowerSeries.jl#L272-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.distribute_p0-Tuple{AbstractPowerSeries, Integer}" href="#StellaratorNearAxis.distribute_p0-Tuple{AbstractPowerSeries, Integer}"><code>StellaratorNearAxis.distribute_p0</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distribute_p0(A::AbstractPowerSeries, p0::Integer)</code></pre><p>If <code>A</code> has an order <code>q0 ≥ p0</code>, creates a new AbstractPowerSeries of the same type with order offset <code>p0</code><code>with equal coefficients. For analyticity to be preserved, we additionally require that</code>q0<code>and</code>p0<code>are even offsets of each other (</code>p0-q0 = 0 mod 2<code>). If</code>p0<code>is not specified, the default value is</code>p0=0`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L684-L691">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.unsafe_distribute_p0" href="#StellaratorNearAxis.unsafe_distribute_p0"><code>StellaratorNearAxis.unsafe_distribute_p0</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unsafe_distribute_p0(A::AbstractPowerSeries[, p0::Integer])</code></pre><p>Creates a new PowerSeries with order offset p0 with equal coefficients to <code>A</code>. For analyticity to be  preserved, we require that <code>q0</code> and <code>p0</code> are even offsets of each other (<code>p0-q0 = 0 mod 2</code>). If <code>p0</code>  is not specified, the default value is <code>p0=0</code>.</p><p>If you are unsure about whether p0 can be increased without losing information,  <a href="#StellaratorNearAxis.remove_zeros-Tuple{AbstractPowerSeries}"><code>remove_zeros</code></a> can automatically check whether the order can be changed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/PowerSeries/Operations.jl#L711-L720">source</a></section></article><h2 id="Coil-Functions"><a class="docs-heading-anchor" href="#Coil-Functions">Coil Functions</a><a id="Coil-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Coil-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.Coil" href="#StellaratorNearAxis.Coil"><code>StellaratorNearAxis.Coil</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Coil</code></pre><p>A coil consists of a filament and a current. It can be constructed by <code>Coil(r0, J, Mcoil)</code>, where  <code>r0</code> is a 3-vector of SpectralPowerSeries, <code>J</code> is a number expressing the current per unit length,  and <code>Mcoil</code> is the number of quadrature nodes for Biot-Savart.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/BiotSavart/BiotSavart.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.load_coils" href="#StellaratorNearAxis.load_coils"><code>StellaratorNearAxis.load_coils</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Input:</p><ul><li><code>coil_file</code>: A JSON file holding the output of a Simsopt coil optimization</li><li><code>Mcoil</code>: The number of coil quadrature nodes for Biot-Savart</li></ul><p>Output:</p><ul><li>The coil set contained in <code>coil_file</code>, which can be used to initialize a near axis expansion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/BiotSavart/BiotSavart.jl#L46-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.evaluate-Union{Tuple{T}, Tuple{AbstractArray{T}, Coil}} where T" href="#StellaratorNearAxis.evaluate-Union{Tuple{T}, Tuple{AbstractArray{T}, Coil}} where T"><code>StellaratorNearAxis.evaluate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate(x::AbstractArray, c::Coil)</code></pre><p>Get the magnetic field from the coil <code>c</code> at points <code>x</code> in a 3×N array. Uses Biot-Savart discretized  via the trapezoidal rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/BiotSavart/BiotSavart.jl#L104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.magnetic_trajectory" href="#StellaratorNearAxis.magnetic_trajectory"><code>StellaratorNearAxis.magnetic_trajectory</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">magnetic_trajectory(cs::Vector{Coil}, x0::AbstractVector, S::Number; tol::Number=1e-8)</code></pre><p>Evolve the magnetic field generated by the coil set <code>cs</code> starting at the point <code>x0</code> a distance <code>S</code> to tolerance <code>tol</code>. Outputs a OrdinaryDiffEq solution object. It also returns the times at which the trajectory passes through the  Poincare surface intersects with the initial toroidal coordinate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/BiotSavart/BiotSavart.jl#L200-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.find_magnetic_axis" href="#StellaratorNearAxis.find_magnetic_axis"><code>StellaratorNearAxis.find_magnetic_axis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_magnetic_axis(x0::AbstractVector, cs::Vector{Coil})</code></pre><p>Find a point on the magnetic axis of a coil set <code>cs</code> with <code>Mcoil</code> quadrature points. Requires an  initial guess of a point on the axis <code>x0</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/BiotSavart/BiotSavart.jl#L275-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.get_field_on_axis" href="#StellaratorNearAxis.get_field_on_axis"><code>StellaratorNearAxis.get_field_on_axis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_field_on_axis(r0::AbstractVector, cs::Vector{Coil}, Mc::Number, N::Number, Mcoil::Number)</code></pre><p>Expand the magnetic field from the coil set <code>cs</code> about the axis <code>r0</code> (found, e.g., via  <a href="#StellaratorNearAxis.find_magnetic_axis"><code>find_magnetic_axis</code></a>). The field is computed on <code>Mc</code> collocation points and converted to a SpectralPowerSeries of order <code>Ms</code> dictated by the value of <code>Ms</code> used to define <code>r0</code>. The field is computed to order <code>N</code> and with <code>Mcoil</code> quadrature points on the coils.</p><p>Output:</p><ul><li><code>B</code>: The magnetic field in Frenet-Serret coordinates</li><li><code>r</code>: The Frenet-Serret coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/BiotSavart/BiotSavart.jl#L317-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.field_to_nae" href="#StellaratorNearAxis.field_to_nae"><code>StellaratorNearAxis.field_to_nae</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">field_to_nae(r0_s::AbstractVector{SpectralPowerSeries{T}}, 
    Bsup_s::AbstractVector{SpectralPowerSeries{T}}, Mc::Integer, K_reg::Integer, 
    N_reg::Integer) where {T}</code></pre><p>Create a DirectNearAxisEquilibrium object with the magnetic field from a coil expansion. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/BiotSavart/BiotSavart.jl#L450-L456">source</a></section></article><h2 id="Direct-Frenet-Serret-Equilibrium-Problem"><a class="docs-heading-anchor" href="#Direct-Frenet-Serret-Equilibrium-Problem">Direct Frenet-Serret Equilibrium Problem</a><a id="Direct-Frenet-Serret-Equilibrium-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-Frenet-Serret-Equilibrium-Problem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.DirectNearAxisEquilibrium" href="#StellaratorNearAxis.DirectNearAxisEquilibrium"><code>StellaratorNearAxis.DirectNearAxisEquilibrium</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DirectNearAxisEquilibrium</code></pre><p>The struct used to represent an equilibrium of the direct near-axis expansion in vacuum. See <a href="#StellaratorNearAxis.InitialVacuumNearAxisEquilibrium"><code>InitialVacuumNearAxisEquilibrium</code></a> to initialize the equilibrium. See <code>DirectFS.jl</code> for member descriptions. We use the convention that <code>_s</code> refers to  SpectralPowerSeries and <code>_c</code> for SpatialPowerSeries (<code>c</code> for <code>collocation</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/DirectFS/DirectFS.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.InitialVacuumNearAxisEquilibrium" href="#StellaratorNearAxis.InitialVacuumNearAxisEquilibrium"><code>StellaratorNearAxis.InitialVacuumNearAxisEquilibrium</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InitialVacuumNearAxisEquilibrium(r0_s::Vector{SpectralPowerSeries{T}},
           Nρ::Integer, Mc::Integer, B0_s::SpectralPowerSeries{T}, 
           K_reg::Number, N_reg::Integer) where {T}</code></pre><p>Initialize a DirectNearAxisEquilibrium, which can then be solved via <a href="#StellaratorNearAxis.vacuum_solve"><code>vacuum_solve</code></a>. Input:</p><ul><li><code>r0_s</code>: The axis <code>r0</code>. The number of spectral modes determines the number of modes <code>Ms</code> for other   SpectralPowerSeries objects.</li><li><code>Nρ</code>: The order of the series</li><li><code>Mc</code>: The number of collocation nodes for SpatialPowerSeries in the pseudospectral method</li><li><code>B0_s</code>: The on-axis magnetic field magnitude</li><li><code>K_reg</code>: The regularization wavenumber cutoff (set to Inf for no regularization)</li><li><code>N_reg</code>: The regularization exponent</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/DirectFS/DirectFS.jl#L223-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.vacuum_solve" href="#StellaratorNearAxis.vacuum_solve"><code>StellaratorNearAxis.vacuum_solve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vacuum_solve(nae::DirectNearAxisEquilibrium, phi_IC::AbstractArray)</code></pre><p>Solve for a vacuum field. If <code>Ms</code> is the number of Fourier modes, and <code>Nρ</code> is the order of the  series the boundary conditions at each order are given by the <code>Ms × 2Nρ-1</code> matrix</p><ul><li><code>phi_IC = [phi_0c0, phi_1c1, phi_1s1, phi_2c2, phi_2s2, ..., phi_NcN, phi_NsN]</code></li></ul><p>Note that the magnetic axis to truely be a magnetic axis, the first three columns are zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/DirectFS/DirectFS.jl#L409-L416">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.get_flux_coordinates" href="#StellaratorNearAxis.get_flux_coordinates"><code>StellaratorNearAxis.get_flux_coordinates</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_flux_coordinates(nae::DirectNearAxisEquilibrium)</code></pre><p>Given a solved DirectNearAxisEquilibrium, find flux coordinates. They can be accessed via <code>nae.ξ_s</code>, and the flux/rotational transform can be found via <code>nae.psi_s</code>/<code>nae.iota</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/DirectFS/DirectFS.jl#L853-L858">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.plot_curve!" href="#StellaratorNearAxis.plot_curve!"><code>StellaratorNearAxis.plot_curve!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_curve!(ax, r0::Vector, M::Number; color=:black)</code></pre><p>Plot a 3D curve from a vector of SpectralPowerSeries <code>r0</code>. Uses <code>M</code> mesh points. Can be used for  both near-axis equilibria (<code>r0 = nae.r0_s</code>) or coils (<code>r0 = coil.r0_s</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/Plotting/SNA_CairoMakie.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.flux_surface_plot!" href="#StellaratorNearAxis.flux_surface_plot!"><code>StellaratorNearAxis.flux_surface_plot!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flux_surface_plot!(ax, nae::DirectNearAxisEquilibrium, u::SpectralPowerSeries, rho0::Number, 
                       theta0::Number, s0::Number; Ntheta::Integer=50, Ns::Integer=50, 
                       colormap=:diverging_isoluminant_cjo_70_c25_n256, kwargs...)</code></pre><p>3D plot a flux surface of a near-axis equilibrium file.  Input:</p><ul><li><code>ax</code>: A 3D CairoMakie <code>CairoMakie.Axis3</code> struct</li><li><code>u</code>: The SpectralPowerSeries to be plotted in direct coordinates (e.g. nae.phi_s)</li><li><code>(rho0,theta0,s0)</code>: A spatial point the flux surface (approximately) intersects</li><li><code>(Ntheta,Ns)</code>: The resolution of the plot</li><li><code>(colormap,kwargs)</code>: Additional arguments for CairoMakie.mesh!</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/Plotting/SNA_CairoMakie.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StellaratorNearAxis.flux_contours!" href="#StellaratorNearAxis.flux_contours!"><code>StellaratorNearAxis.flux_contours!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flux_contours!(ax, xi_s::AbstractVector, rho0::Number, theta0::Number, s0::Number, 
                    Nsurf::Integer; Ntheta = 101, color=:black, kwargs...)</code></pre><p>Contour plot of flux surfaces on a cross section Input:</p><ul><li><code>ax</code>: A 3D CairoMakie <code>CairoMakie.Axis</code> struct</li><li><code>xi_s</code>: The SpectralPowerSeries vector defining the flux surfaces (e.g. <code>nae.xi_s</code>)</li><li><code>(rho0,theta0)</code>: A point on a Poincare section which the outermost surface intersects</li><li><code>s0</code>: The Poincare section taken</li><li><code>Nsurf</code>: The number of surfaces to plot</li><li><code>Ntheta</code>: Number of points used to plot each surface</li><li><code>(color,kwargs)</code>: Additional arguments for CairoMakie.lines!</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/StellaratorNearAxis.jl/blob/2248e6f55af5b2f64dd60c00120fa987b9b0e8fa/src/Plotting/SNA_CairoMakie.jl#L59-L72">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« StellaratorNearAxis.jl</a><a class="docs-footer-nextpage" href="../../examples/example/">Example »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 20 November 2024 23:39">Wednesday 20 November 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
